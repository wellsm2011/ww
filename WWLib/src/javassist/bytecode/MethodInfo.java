/*
 * Javassist, a Java-bytecode translator toolkit.
 * Copyright (C) 1999- Shigeru Chiba. All Rights Reserved.
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License.  Alternatively, the contents of this file may be used under
 * the terms of the GNU Lesser General Public License Version 2.1 or later,
 * or the Apache License Version 2.0.
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 */

package javassist.bytecode;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import javassist.ClassPool;
import javassist.bytecode.stackmap.MapMaker;

/**
 * <code>method_info</code> structure.
 * <p>
 * The bytecode sequence of the method is represented by a
 * <code>CodeAttribute</code> object.
 * <p>
 * The following code adds the default constructor to a class: of
 * <code>int</code> type: <blockquote>
 *
 * <pre>
 * ClassFile cf = ...
 * Bytecode code = new Bytecode(cf.getConstPool());
 * code.addAload(0);
 * code.addInvokespecial("java/lang/Object", MethodInfo.nameInit, "()V");
 * code.addReturn(null);
 * code.setMaxLocals(1);
 * 
 * MethodInfo minfo = new MethodInfo(cf.getConstPool(), MethodInfo.nameInit, "()V");
 * minfo.setCodeAttribute(code.toCodeAttribute());
 * cf.addMethod(minfo);
 * </pre>
 *
 * </blockquote>
 *
 * @see #getCodeAttribute()
 * @see CodeAttribute
 * @see Bytecode
 * @see javassist.CtMethod#getMethodInfo()
 * @see javassist.CtConstructor#getMethodInfo()
 */
public class MethodInfo
{
	/**
	 * If this value is true, Javassist maintains a <code>StackMap</code>
	 * attribute generated by the <code>preverify</code> tool of J2ME (CLDC).
	 * The initial value of this field is <code>false</code>.
	 */
	public static boolean		doPreverify	= false;
	/**
	 * The name of constructors: <code>&lt;init&gt;</code>.
	 */
	public static final String	nameInit	= "<init>";
	/**
	 * The name of class initializer (static initializer):
	 * <code>&lt;clinit&gt;</code>.
	 */
	public static final String	nameClinit	= "<clinit>";
	ConstPool					constPool;
	int							accessFlags;
	int							name;

	String						cachedName;

	int							descriptor;

	ArrayList					attribute;					// may be null

	private MethodInfo(ConstPool cp)
	{
		this.constPool = cp;
		this.attribute = null;
	}

	MethodInfo(ConstPool cp, DataInputStream in) throws IOException
	{
		this(cp);
		this.read(in);
	}

	/**
	 * Constructs a copy of <code>method_info</code> structure. Class names
	 * appearing in the source <code>method_info</code> are renamed according to
	 * <code>classnameMap</code>.
	 * <p>
	 * Note: only <code>Code</code> and <code>Exceptions</code> attributes are
	 * copied from the source. The other attributes are ignored.
	 *
	 * @param cp
	 *            a constant pool table
	 * @param methodname
	 *            a method name
	 * @param src
	 *            a source <code>method_info</code>
	 * @param classnameMap
	 *            specifies pairs of replaced and substituted name.
	 * @see Descriptor
	 */
	public MethodInfo(ConstPool cp, String methodname, MethodInfo src, Map classnameMap) throws BadBytecode
	{
		this(cp);
		this.read(src, methodname, classnameMap);
	}

	/**
	 * Constructs a <code>method_info</code> structure. The initial value of
	 * <code>access_flags</code> is zero.
	 *
	 * @param cp
	 *            a constant pool table
	 * @param methodname
	 *            method name
	 * @param desc
	 *            method descriptor
	 * @see Descriptor
	 */
	public MethodInfo(ConstPool cp, String methodname, String desc)
	{
		this(cp);
		this.accessFlags = 0;
		this.name = cp.addUtf8Info(methodname);
		this.cachedName = methodname;
		this.descriptor = this.constPool.addUtf8Info(desc);
	}

	/**
	 * Appends an attribute. If there is already an attribute with the same
	 * name, the new one substitutes for it.
	 *
	 * @see #getAttributes()
	 */
	public void addAttribute(AttributeInfo info)
	{
		if (this.attribute == null)
			this.attribute = new ArrayList();

		AttributeInfo.remove(this.attribute, info.getName());
		this.attribute.add(info);
	}

	/**
	 * Copies all constant pool items to a given new constant pool and replaces
	 * the original items with the new ones. This is used for garbage collecting
	 * the items of removed fields and methods.
	 *
	 * @param cp
	 *            the destination
	 */
	void compact(ConstPool cp)
	{
		this.name = cp.addUtf8Info(this.getName());
		this.descriptor = cp.addUtf8Info(this.getDescriptor());
		this.attribute = AttributeInfo.copyAll(this.attribute, cp);
		this.constPool = cp;
	}

	/**
	 * Returns access flags.
	 *
	 * @see AccessFlag
	 */
	public int getAccessFlags()
	{
		return this.accessFlags;
	}

	/**
	 * Returns the attribute with the specified name. If it is not found, this
	 * method returns null.
	 *
	 * @param name
	 *            attribute name
	 * @return an <code>AttributeInfo</code> object or null.
	 * @see #getAttributes()
	 */
	public AttributeInfo getAttribute(String name)
	{
		return AttributeInfo.lookup(this.attribute, name);
	}

	/**
	 * Returns all the attributes. The returned <code>List</code> object is
	 * shared with this object. If you add a new attribute to the list, the
	 * attribute is also added to the method represented by this object. If you
	 * remove an attribute from the list, it is also removed from the method.
	 *
	 * @return a list of <code>AttributeInfo</code> objects.
	 * @see AttributeInfo
	 */
	public List getAttributes()
	{
		if (this.attribute == null)
			this.attribute = new ArrayList();

		return this.attribute;
	}

	/**
	 * Returns a Code attribute.
	 *
	 * @return a Code attribute or null if it is not specified.
	 */
	public CodeAttribute getCodeAttribute()
	{
		AttributeInfo info = AttributeInfo.lookup(this.attribute, CodeAttribute.tag);
		return (CodeAttribute) info;
	}

	/**
	 * Returns a constant pool table used by this method.
	 */
	public ConstPool getConstPool()
	{
		return this.constPool;
	}

	/**
	 * Returns a method descriptor.
	 *
	 * @see Descriptor
	 */
	public String getDescriptor()
	{
		return this.constPool.getUtf8Info(this.descriptor);
	}

	/**
	 * Returns an Exceptions attribute.
	 *
	 * @return an Exceptions attribute or null if it is not specified.
	 */
	public ExceptionsAttribute getExceptionsAttribute()
	{
		AttributeInfo info = AttributeInfo.lookup(this.attribute, ExceptionsAttribute.tag);
		return (ExceptionsAttribute) info;
	}

	/**
	 * Returns the line number of the source line corresponding to the specified
	 * bytecode contained in this method.
	 *
	 * @param pos
	 *            the position of the bytecode (&gt;= 0). an index into the code
	 *            array.
	 * @return -1 if this information is not available.
	 */
	public int getLineNumber(int pos)
	{
		CodeAttribute ca = this.getCodeAttribute();
		if (ca == null)
			return -1;

		LineNumberAttribute ainfo = (LineNumberAttribute) ca.getAttribute(LineNumberAttribute.tag);
		if (ainfo == null)
			return -1;

		return ainfo.toLineNumber(pos);
	}

	/**
	 * Returns a method name.
	 */
	public String getName()
	{
		if (this.cachedName == null)
			this.cachedName = this.constPool.getUtf8Info(this.name);

		return this.cachedName;
	}

	/**
	 * Returns true if this is a constructor.
	 */
	public boolean isConstructor()
	{
		return this.getName().equals(MethodInfo.nameInit);
	}

	/**
	 * Returns true if this is not a constructor or a class initializer (static
	 * initializer).
	 */
	public boolean isMethod()
	{
		String n = this.getName();
		return !n.equals(MethodInfo.nameInit) && !n.equals(MethodInfo.nameClinit);
	}

	/**
	 * Returns true if this is a class initializer (static initializer).
	 */
	public boolean isStaticInitializer()
	{
		return this.getName().equals(MethodInfo.nameClinit);
	}

	void prune(ConstPool cp)
	{
		ArrayList newAttributes = new ArrayList();

		AttributeInfo invisibleAnnotations = this.getAttribute(AnnotationsAttribute.invisibleTag);
		if (invisibleAnnotations != null)
		{
			invisibleAnnotations = invisibleAnnotations.copy(cp, null);
			newAttributes.add(invisibleAnnotations);
		}

		AttributeInfo visibleAnnotations = this.getAttribute(AnnotationsAttribute.visibleTag);
		if (visibleAnnotations != null)
		{
			visibleAnnotations = visibleAnnotations.copy(cp, null);
			newAttributes.add(visibleAnnotations);
		}

		AttributeInfo parameterInvisibleAnnotations = this.getAttribute(ParameterAnnotationsAttribute.invisibleTag);
		if (parameterInvisibleAnnotations != null)
		{
			parameterInvisibleAnnotations = parameterInvisibleAnnotations.copy(cp, null);
			newAttributes.add(parameterInvisibleAnnotations);
		}

		AttributeInfo parameterVisibleAnnotations = this.getAttribute(ParameterAnnotationsAttribute.visibleTag);
		if (parameterVisibleAnnotations != null)
		{
			parameterVisibleAnnotations = parameterVisibleAnnotations.copy(cp, null);
			newAttributes.add(parameterVisibleAnnotations);
		}

		AnnotationDefaultAttribute defaultAttribute = (AnnotationDefaultAttribute) this.getAttribute(AnnotationDefaultAttribute.tag);
		if (defaultAttribute != null)
			newAttributes.add(defaultAttribute);

		ExceptionsAttribute ea = this.getExceptionsAttribute();
		if (ea != null)
			newAttributes.add(ea);

		AttributeInfo signature = this.getAttribute(SignatureAttribute.tag);
		if (signature != null)
		{
			signature = signature.copy(cp, null);
			newAttributes.add(signature);
		}

		this.attribute = newAttributes;
		this.name = cp.addUtf8Info(this.getName());
		this.descriptor = cp.addUtf8Info(this.getDescriptor());
		this.constPool = cp;
	}

	private void read(DataInputStream in) throws IOException
	{
		this.accessFlags = in.readUnsignedShort();
		this.name = in.readUnsignedShort();
		this.descriptor = in.readUnsignedShort();
		int n = in.readUnsignedShort();
		this.attribute = new ArrayList();
		for (int i = 0; i < n; ++i)
			this.attribute.add(AttributeInfo.read(this.constPool, in));
	}

	private void read(MethodInfo src, String methodname, Map classnames) throws BadBytecode
	{
		ConstPool destCp = this.constPool;
		this.accessFlags = src.accessFlags;
		this.name = destCp.addUtf8Info(methodname);
		this.cachedName = methodname;
		ConstPool srcCp = src.constPool;
		String desc = srcCp.getUtf8Info(src.descriptor);
		String desc2 = Descriptor.rename(desc, classnames);
		this.descriptor = destCp.addUtf8Info(desc2);

		this.attribute = new ArrayList();
		ExceptionsAttribute eattr = src.getExceptionsAttribute();
		if (eattr != null)
			this.attribute.add(eattr.copy(destCp, classnames));

		CodeAttribute cattr = src.getCodeAttribute();
		if (cattr != null)
			this.attribute.add(cattr.copy(destCp, classnames));
	}

	/**
	 * Rebuilds a stack map table. If no stack map table is included, a new one
	 * is created. If this <code>MethodInfo</code> does not include a code
	 * attribute, nothing happens.
	 *
	 * @param pool
	 *            used for making type hierarchy.
	 * @see StackMapTable
	 * @since 3.6
	 */
	public void rebuildStackMap(ClassPool pool) throws BadBytecode
	{
		CodeAttribute ca = this.getCodeAttribute();
		if (ca != null)
		{
			StackMapTable smt = MapMaker.make(pool, this);
			ca.setAttribute(smt);
		}
	}

	/**
	 * Rebuilds a stack map table for J2ME (CLDC). If no stack map table is
	 * included, a new one is created. If this <code>MethodInfo</code> does not
	 * include a code attribute, nothing happens.
	 *
	 * @param pool
	 *            used for making type hierarchy.
	 * @see StackMap
	 * @since 3.12
	 */
	public void rebuildStackMapForME(ClassPool pool) throws BadBytecode
	{
		CodeAttribute ca = this.getCodeAttribute();
		if (ca != null)
		{
			StackMap sm = MapMaker.make2(pool, this);
			ca.setAttribute(sm);
		}
	}

	/**
	 * Rebuilds a stack map table if the class file is for Java 6 or later. Java
	 * 5 or older Java VMs do not recognize a stack map table. If
	 * <code>doPreverify</code> is true, this method also rebuilds a stack map
	 * for J2ME (CLDC).
	 *
	 * @param pool
	 *            used for making type hierarchy.
	 * @param cf
	 *            rebuild if this class file is for Java 6 or later.
	 * @see #rebuildStackMap(ClassPool)
	 * @see #rebuildStackMapForME(ClassPool)
	 * @see #doPreverify
	 * @since 3.6
	 */
	public void rebuildStackMapIf6(ClassPool pool, ClassFile cf) throws BadBytecode
	{
		if (cf.getMajorVersion() >= ClassFile.JAVA_6)
			this.rebuildStackMap(pool);

		if (MethodInfo.doPreverify)
			this.rebuildStackMapForME(pool);
	}

	/**
	 * Removes a Code attribute.
	 */
	public void removeCodeAttribute()
	{
		AttributeInfo.remove(this.attribute, CodeAttribute.tag);
	}

	/**
	 * Removes an Exception attribute.
	 */
	public void removeExceptionsAttribute()
	{
		AttributeInfo.remove(this.attribute, ExceptionsAttribute.tag);
	}

	/**
	 * Sets access flags.
	 *
	 * @see AccessFlag
	 */
	public void setAccessFlags(int acc)
	{
		this.accessFlags = acc;
	}

	/**
	 * Adds a Code attribute.
	 * <p>
	 * The added attribute must share the same constant pool table as this
	 * <code>method_info</code> structure.
	 */
	public void setCodeAttribute(CodeAttribute cattr)
	{
		this.removeCodeAttribute();
		if (this.attribute == null)
			this.attribute = new ArrayList();

		this.attribute.add(cattr);
	}

	/**
	 * Sets a method descriptor.
	 *
	 * @see Descriptor
	 */
	public void setDescriptor(String desc)
	{
		if (!desc.equals(this.getDescriptor()))
			this.descriptor = this.constPool.addUtf8Info(desc);
	}

	/**
	 * Adds an Exception attribute.
	 * <p>
	 * The added attribute must share the same constant pool table as this
	 * <code>method_info</code> structure.
	 */
	public void setExceptionsAttribute(ExceptionsAttribute cattr)
	{
		this.removeExceptionsAttribute();
		if (this.attribute == null)
			this.attribute = new ArrayList();

		this.attribute.add(cattr);
	}

	/**
	 * Sets a method name.
	 */
	public void setName(String newName)
	{
		this.name = this.constPool.addUtf8Info(newName);
		this.cachedName = newName;
	}

	/**
	 * Changes a super constructor called by this constructor.
	 * <p>
	 * This method modifies a call to <code>super()</code>, which should be at
	 * the head of a constructor body, so that a constructor in a different
	 * super class is called. This method does not change actual parameters.
	 * Hence the new super class must have a constructor with the same signature
	 * as the original one.
	 * <p>
	 * This method should be called when the super class of the class declaring
	 * this method is changed.
	 * <p>
	 * This method does not perform anything unless this <code>MethodInfo</code>
	 * represents a constructor.
	 *
	 * @param superclass
	 *            the new super class
	 */
	public void setSuperclass(String superclass) throws BadBytecode
	{
		if (!this.isConstructor())
			return;

		CodeAttribute ca = this.getCodeAttribute();
		byte[] code = ca.getCode();
		CodeIterator iterator = ca.iterator();
		int pos = iterator.skipSuperConstructor();
		if (pos >= 0)
		{ // not this()
			ConstPool cp = this.constPool;
			int mref = ByteArray.readU16bit(code, pos + 1);
			int nt = cp.getMethodrefNameAndType(mref);
			int sc = cp.addClassInfo(superclass);
			int mref2 = cp.addMethodrefInfo(sc, nt);
			ByteArray.write16bit(mref2, code, pos + 1);
		}
	}

	/**
	 * Returns a string representation of the object.
	 */
	@Override
	public String toString()
	{
		return this.getName() + " " + this.getDescriptor();
	}

	void write(DataOutputStream out) throws IOException
	{
		out.writeShort(this.accessFlags);
		out.writeShort(this.name);
		out.writeShort(this.descriptor);

		if (this.attribute == null)
			out.writeShort(0);
		else
		{
			out.writeShort(this.attribute.size());
			AttributeInfo.writeAll(this.attribute, out);
		}
	}
}
